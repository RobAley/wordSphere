<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Graph</title>
    <style>
      svg {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
      }
      .node circle {
          stroke: #fff;
          stroke-width: 2px;
      }
      .link {
          stroke: #888;
          stroke-width: 2px;
      }
    </style>
  </head>
  <body>
    <script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
    <script>
      $(function() {
          "use strict";

          var color = d3.scale.category20();

          var force = d3.layout.force()
              .charge(-120)
              .linkDistance(100)
              .size([$(window).innerWidth(), $(window).innerHeight()]);
          $(window).on('resize', function() {
              force.size([$('svg').width(), $('svg').height()]);
          });
          var scrollX = 0;
          var scrollY = 0;
          var svg = d3.select("body").append("svg");

          function reconstruct_links(graph) {
              $.each(graph.nodes, function(i, node) {
                  node.index = i;
              });
              $.each(graph.links, function(i, link) {
                  link.source = graph.nodes[typeof(link.source) === "number" ? link.source : link.source.index];
                  link.target = graph.nodes[typeof(link.target) === "number" ? link.target : link.target.index];
              });
          }

          function index_words(graph) {
              var indices = {};
              $.each(graph.nodes, function(i, n) { indices[n.name] = i; });
              return indices;
          }

          function calculate_neighbors(graph) {
              var neighbors = [];
              $.each(graph.links, function(i, link) {
                  neighbors[link.source.index] = neighbors[link.source.index] || [];
                  neighbors[link.target.index] = neighbors[link.target.index] || [];

                  neighbors[link.source.index].push(link.target.index);
                  neighbors[link.target.index].push(link.source.index);
              });
              return neighbors;
          }

          var graph_original = null;
          var word_indices = null;
          var neighbors = null;
          function update() {
              function nodes_to_show(word) {
                  var to_be_shown = {};
                  var stack = [word_indices[word]];
                  while (stack.length > 0) {
                      var ni = stack.pop();
                      to_be_shown[ni] = true;
                      $.each(neighbors[ni], function(i, nni) {
                          if (!to_be_shown[nni]) {
                              stack.push(nni);
                          }
                      });
                  }
                  return to_be_shown;
              }
              var to_be_shown = nodes_to_show("fall");

              var graph = {};
              graph.links = graph_original.links.filter(function(l) { return to_be_shown[l.source.index] || to_be_shown[l.target.index]; });
              graph.nodes = graph_original.nodes.filter(function(n) { return to_be_shown[n.index]; });

              force
                  .nodes(graph.nodes)
                  .links(graph.links)
                  .start();
              var link = svg.selectAll(".link")
                  .data(graph.links)
                  .enter().append("line")
                  .attr("class", "link");
              var node = svg.selectAll(".node")
                  .data(graph.nodes)
                  .enter().append("g")
                  .attr("id", function(d) { return d.name || "synset" + d.synset_id; })
                  .attr("class", "node")
                  .attr("transform", function(d) { return "translate(" + d.x + ", " + d.y + ")"; });

              node.append("circle")
                  .attr("r", function(d) { return d.name ? 5 : 10; })
                  .style("fill", function(d) { return d.name ? "gray" : color(d.synset_id); });

              node.append("text")
                  .text(function(d) { return d.name || ""; });

              force.on("tick", function() {
                  link.attr("x1", function(d) { return scrollX + d.source.x; })
                      .attr("y1", function(d) { return scrollY + d.source.y; })
                      .attr("x2", function(d) { return scrollX + d.target.x; })
                      .attr("y2", function(d) { return scrollY + d.target.y; });

                  node.attr("transform", function(d) { return "translate(" + (scrollX + d.x) + ", " + (scrollY + d.y) + ")"; });
              });

              var grab = null;
              $("svg").on("mousedown", function(e) {
                  if (e.which === 1) {
                      grab = {
                          pageX: e.pageX,
                          pageY: e.pageY,
                          scrollX: scrollX,
                          scrollY: scrollY
                      };
                  }
              });
              $("svg").on("mousemove", function(e) {
                  if (e.which === 1 && grab) {
                      scrollX = grab.scrollX + (e.pageX - grab.pageX);
                      scrollY = grab.scrollY + (e.pageY - grab.pageY);
                      link.attr("x1", function(d) { return scrollX + d.source.x; })
                          .attr("y1", function(d) { return scrollY + d.source.y; })
                          .attr("x2", function(d) { return scrollX + d.target.x; })
                          .attr("y2", function(d) { return scrollY + d.target.y; });

                      node.attr("transform", function(d) { return "translate(" + (scrollX + d.x) + ", " + (scrollY + d.y) + ")"; });
                  }
              });
              $("svg").on("mouseup", function(e) {
                  if (e.which === 1) {
                      grab = null;
                  }
              });
          }

          d3.json("test.json", function(error, graph) {
              reconstruct_links(graph);
              word_indices = index_words(graph);
              neighbors = calculate_neighbors(graph);
              graph_original = graph;
              update();
          });
      });
    </script>
  </body>
</html>
